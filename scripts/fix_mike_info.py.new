#!/usr/bin/env python3
"""
This script cleans up .mike/info.json and version directories
to remove any 'latest' references that might conflict with
MkDocs documentation deployment using Mike.
"""
import json
import os
import sys
import shutil
import re
from typing import Any, Dict, List

# Mike configuration locations
MIKE_INFO_FILE = ".mike/info.json"
MIKE_VERSIONS_DIR = ".mike/versions"


def cleanup_mike_directories() -> bool:
    """Clean up any directories in .mike/versions that might cause conflicts"""
    if not os.path.isdir(MIKE_VERSIONS_DIR):
        print(f"No {MIKE_VERSIONS_DIR} directory found")
        return False

    changes_made = False

    def remove_conflicting_directory(dir_path: str) -> bool:
        """Helper function to remove a directory and handle exceptions"""
        if os.path.isdir(dir_path):
            print(f"Removing conflicting directory: {dir_path}")
            try:
                shutil.rmtree(dir_path)
                return True
            except Exception as e:
                print(f"Error removing directory {dir_path}: {e}")
        return False

    def matches_latest_pattern(item: str) -> bool:
        """Helper function to check if an item matches 'latest' patterns"""
        item_lower = item.lower()
        return (
            'latest' in item_lower or
            bool(re.match(r'^latest.*\(.*\)$', item_lower)) or
            bool(re.match(r'^"?latest.*\(.*\)"?$', item_lower))
        )

    for item in os.listdir(MIKE_VERSIONS_DIR):
        dir_path = os.path.join(MIKE_VERSIONS_DIR, item)
        if matches_latest_pattern(item):
            if remove_conflicting_directory(dir_path):
                changes_made = True

    return changes_made


def clean_aliases(data: Dict[str, Any]) -> bool:
    """Remove any 'latest' aliases from the data"""
    if "aliases" not in data:
        data["aliases"] = {}
        return False

    changes_made = False
    # Get keys to avoid modifying dict during iteration
    aliases: List[str] = list(data["aliases"].keys())

    for alias in aliases:
        if alias.lower() == "latest":
            version: str = data["aliases"][alias]
            print(f"Removing alias latest -> {version}")
            del data["aliases"][alias]
            changes_made = True

    return changes_made


def clean_versions(data: Dict[str, Any]) -> bool:
    """Remove any versions with 'latest' in the name"""
    if "versions" not in data:
        data["versions"] = []
        return False

    original_count: int = len(data["versions"])
    # Filter out any versions with 'latest' in the name
    filtered_versions: List[Any] = []

    for version in data["versions"]:
        if version is None:
            continue

        version_str: str = str(version).lower()
        if "latest" in version_str:
            print(f"Removing version {version}")
        else:
            filtered_versions.append(version)

    # Also check for versions like "Latest (main)"
    newly_filtered: List[Any] = []
    for version in filtered_versions:
        if version is None:
            continue

        version_str_filtered: str = str(version).lower()
        if re.match(
            r'^latest.*\(.*\)$', version_str_filtered
        ) or re.match(
            r'^"?latest.*\(.*\)"?$', version_str_filtered
        ):
            print(f"Removing 'Latest ()' version: {version}")
        else:
            newly_filtered.append(version)

    data["versions"] = newly_filtered
    return len(newly_filtered) < original_count


def fix_version_title_map(data: Dict[str, Any]) -> bool:
    """Fix the version_title_map to remove any 'latest' references"""
    if "version_title_map" not in data:
        return False

    changes_made = False
    keys_to_remove: List[str] = []

    for version in data.get("version_title_map", {}).keys():
        version_lower: str = (
            version.lower() if isinstance(version, str) else ""
        )
        if "latest" in version_lower:
            print(f"Removing version_title_map entry for {version}")
            keys_to_remove.append(version)
            changes_made = True

    for key in keys_to_remove:
        if key in data["version_title_map"]:
            del data["version_title_map"][key]

    return changes_made


def fix_mike_info_file() -> bool:
    """Fix the .mike/info.json file"""
    if not os.path.isfile(MIKE_INFO_FILE):
        print(f"No {MIKE_INFO_FILE} file found")
        return False

    # Load the JSON data
    try:
        with open(MIKE_INFO_FILE, "r") as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error parsing {MIKE_INFO_FILE}: {e}")
        print("Creating backup of corrupted file...")
        # Backup corrupted file
        backup_path = f"{MIKE_INFO_FILE}.corrupted"
        if os.path.exists(backup_path):
            os.remove(backup_path)
        try:
            os.rename(MIKE_INFO_FILE, backup_path)
        except Exception as e:
            print(f"Failed to create backup: {e}")

        # Create a minimal valid JSON structure
        data: Dict[str, List[Any]] = {"aliases": [], "versions": []}
        changes_made = True
    else:
        # Clean the data
        aliases_changed = clean_aliases(data)
        versions_changed = clean_versions(data)
        title_map_changed = fix_version_title_map(data)
        changes_made = aliases_changed or versions_changed or title_map_changed

    # Save changes if needed
    if changes_made:
        try:
            with open(f"{MIKE_INFO_FILE}.fixed", "w") as f:
                json.dump(data, f, indent=2)
            os.replace(f"{MIKE_INFO_FILE}.fixed", MIKE_INFO_FILE)
            print(f"Successfully cleaned up {MIKE_INFO_FILE}")
        except Exception as e:
            print(f"Error saving cleaned file: {e}")
            return False

    return changes_made


def main() -> bool:
    """Main function to clean Mike configuration"""
    try:
        print("=== Mike Configuration Cleaner ===")
        dir_changes = False
        file_changes = False

        # Create the .mike directory if it doesn't exist
        mike_dir = os.path.dirname(MIKE_INFO_FILE)
        if not os.path.isdir(mike_dir):
            try:
                os.makedirs(mike_dir, exist_ok=True)
                print(f"Created {mike_dir} directory")
            except Exception as e:
                print(f"Failed to create {mike_dir} directory: {e}")

        # Clean up directories first
        try:
            dir_changes = cleanup_mike_directories()
        except Exception as e:
            print(f"Directory cleanup failed: {e}")

        # Now clean up the info.json file
        try:
            file_changes = fix_mike_info_file()
        except Exception as e:
            print(f"File cleanup failed: {e}")

        if not dir_changes and not file_changes:
            print("No 'latest' references found in Mike configuration")
        else:
            print("Mike configuration cleanup completed successfully")

        return True
    except Exception as e:
        print(f"Error: {e}")
        return False


if __name__ == "__main__":
    success = main()
    print(f"Script finished with {'success' if success else 'errors'}")
    sys.exit(0 if success else 1)
